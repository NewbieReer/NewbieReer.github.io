<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="c++逆向（一）">
<meta property="og:type" content="article">
<meta property="og:title" content="继承和多重继承">
<meta property="og:url" content="http://example.com/2022/03/16/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/index.html">
<meta property="og:site_name" content="NewbieReer&#39;s blog">
<meta property="og:description" content="c++逆向（一）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210831140327245.png">
<meta property="og:image" content="http://example.com/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210916155258109.png">
<meta property="og:image" content="http://example.com/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210918114232827.png">
<meta property="og:image" content="http://example.com/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210918114328733.png">
<meta property="og:image" content="http://example.com/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210918114718569.png">
<meta property="og:image" content="http://example.com/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210918115710515.png">
<meta property="article:published_time" content="2022-03-16T10:45:55.721Z">
<meta property="article:modified_time" content="2022-03-16T10:51:01.524Z">
<meta property="article:author" content="NewbieReer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210831140327245.png">


<link rel="canonical" href="http://example.com/2022/03/16/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/03/16/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/","path":"2022/03/16/继承和多重继承/","title":"继承和多重继承"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>继承和多重继承 | NewbieReer's blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">NewbieReer's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags<span class="badge">0</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories<span class="badge">0</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives<span class="badge">14</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <!-- require APlayer -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
      <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
      <!-- require MetingJS-->
      <script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
      <!--������playlist������ַ-->   


      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%86%E5%88%AB%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">识别类与类之间的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E3%80%81%E8%99%9A%E8%A1%A8"><span class="nav-text">多态、虚表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E7%B1%BB%E9%83%BD%E6%9C%89%E8%99%9A%E8%A1%A8"><span class="nav-text">父子类都有虚表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-text">定义其他对象+初始化列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E5%88%86%E6%9E%90"><span class="nav-text">综合分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-text">多重继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E6%80%BB%E7%BB%93"><span class="nav-text">特征总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="nav-text">虚基类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="nav-text">菱形继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E4%B8%89%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-text">c++三种继承方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-text">初始化列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">关于虚函数和纯虚函数</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NewbieReer"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">NewbieReer</p>
  <div class="site-description" itemprop="description">一篇诗，一斗酒，一曲长歌，一剑天涯</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://psyduck0409.github.io/" title="DaiDai → https:&#x2F;&#x2F;psyduck0409.github.io&#x2F;" rel="noopener" target="_blank">DaiDai</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://justloseit.top/" title="Joker → http:&#x2F;&#x2F;justloseit.top&#x2F;" rel="noopener" target="_blank">Joker</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://s0uthwood.github.io/" title="s0uthwood&#39;s Blog → https:&#x2F;&#x2F;s0uthwood.github.io&#x2F;" rel="noopener" target="_blank">s0uthwood's Blog</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://kfxp12138.github.io/" title="triplewings → https:&#x2F;&#x2F;kfxp12138.github.io&#x2F;" rel="noopener" target="_blank">triplewings</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://fyhssgss.github.io/" title="ssgss → https:&#x2F;&#x2F;fyhssgss.github.io&#x2F;" rel="noopener" target="_blank">ssgss</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://xz1548.github.io/" title="xz1548 → https:&#x2F;&#x2F;xz1548.github.io&#x2F;" rel="noopener" target="_blank">xz1548</a>
      </span>
  </div>



          </div>
        </div>
      </div>
      <meting-js
          style="display: none"
          server="netease"
          type="playlist" 
          id="6987135743"
          mini="true"
          fixed="false"
          list-folded="false"
          autoplay="true"
          volume="0.2"
          theme="#FADFA3"
          order="random"
          loop="all"
          preload="auto"
          mutex="true">
      </meting-js>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/16/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="NewbieReer">
      <meta itemprop="description" content="一篇诗，一斗酒，一曲长歌，一剑天涯">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NewbieReer's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          继承和多重继承
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-16 18:45:55 / Modified: 18:51:01" itemprop="dateCreated datePublished" datetime="2022-03-16T18:45:55+08:00">2022-03-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>c++逆向（一）</p>
<span id="more"></span>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="识别类与类之间的关系"><a href="#识别类与类之间的关系" class="headerlink" title="识别类与类之间的关系"></a>识别类与类之间的关系</h2><p><a href="#c++%E4%B8%89%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">这里</a>附c++继承说明。子类对象的内存结构中，父类私有数据成员依然存在，也就是说c++语法规定的访问控制仅限于编译层面。</p>
<p><strong>当子类【没有构造函数】，而父类有构造函数时，编译器会为子类添加默认构造函数：</strong></p>
<p><strong>子类的成员函数</strong>：</p>
<p>​        第一个参数是对象首地址*lea ecx,[ebp-14h]*，后面的参数是成员函数所需的剩余变量。</p>
<p><strong>子类的构造函数</strong>：<br>        <em>注：先 pop ecx 还原this指针</em><br>        然后使用ecx调用父类构造函数。</p>
<p><strong>子类的析构函数</strong>：<br>        <em>注：先 pop ecx 还原this指针</em><br>        然后使用ecx调用父类析构函数。</p>
<p>​    子类继承父类，因此子类有父类中各成员。内存结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span>&#123;</span>...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerive</span>&#123;</span>	<span class="comment">//先安排父类数据，再安排子类数据</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CBase m_Base;	<span class="comment">//原来父类CBase成为数据成员</span></span><br><span class="line">    <span class="keyword">int</span> m_nDervie;	<span class="comment">//原来子类派生数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    父类<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="这个时候父类有构造函数。
">[2]</span></a></sup>成为了子类的一个成员对象，因此产生子类的时候先调用父类的构造函数。因为子类没有构造函数，为了<strong>能够在子类产生时，调用父类成员对象的构造函数</strong>，编译器会为子类<strong>提供默认构造函数</strong>。<br>​    然而，如果<strong>子类有</strong>构造函数，而<strong>父类没有</strong>构造函数，编译器不会为父类提供默认构造函数，除非父类有虚函数<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="编译器会提供构造函数帮助父类初始化虚表。
">[3]</span></a></sup>。<br>​    当子类被销毁时，父类也被销毁，为了调用父类的析构函数，编译器为子类提供默认的析构函数。子类销毁的时候<strong>先执行自身的析构代码，再执行父类的析构代码</strong>。<br>​        由上述调用顺序，可以找到类之间的关系，并且区别出析构函数和构造函数。</p>
<p>​    总体而言，上述的内存结构是【this+0为父类部分】，而【this+4为子类新派生部分】。也就是说，在调用thiscall的【父类】函数传参的时候，传递的参数可以就是子类指针。<br>​    **注意：类似于CDerive <em>pDerive = (CDerive <em>)&amp;base，这种子类指针访问pDerive-&gt;m_nDerive，有可能造成越界，反之则不会。</em></em></p>
<h3 id="多态、虚表"><a href="#多态、虚表" class="headerlink" title="多态、虚表"></a>多态、虚表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">CPerson</span>()&#123;&#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">CPerson</span>()&#123;&#125;		<span class="comment">//第一个虚函数</span></span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowSpeak</span><span class="params">()</span>	<span class="comment">//第二个虚函数</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class CChinese : public CPerson&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">CChinese</span>()&#123;&#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">CChinese</span>()&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowSpeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Speak Chinese\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CGerman CAmerican 省略</span></span><br><span class="line">									|对比无对象指针虚函数</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speak</span><span class="params">(CPerson * pPerson)</span></span>&#123;		|MyVitrual.<span class="built_in">SetNumber</span>(参数)<span class="comment">//注意下面是在SetNumber的外面</span></span><br><span class="line">    pPerson-&gt;<span class="built_in">ShowSpeak</span>();			|	参数-&gt;eax</span><br><span class="line">    <span class="comment">//arg1  -&gt; eax	虚表地址的指针	   |	push eax</span></span><br><span class="line">    <span class="comment">//[eax] -&gt; edx	虚表地址		 |  	this-&gt;ecx</span></span><br><span class="line">    <span class="comment">//arg1	-&gt; ecx	this			|	直接call CVirtual::SetNumber	无法构成多态</span></span><br><span class="line">    <span class="comment">//call	[edx+4]	注意是第二个虚函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    CChinese Chinese;</span><br><span class="line">    CAmerican American;</span><br><span class="line">    CGerman	German;</span><br><span class="line">    <span class="built_in">Speak</span>(&amp;Chinese);</span><br><span class="line">    <span class="built_in">Speak</span>(&amp;American);</span><br><span class="line">    <span class="built_in">Speak</span>(&amp;German);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="父子类都有虚表"><a href="#父子类都有虚表" class="headerlink" title="父子类都有虚表"></a>父子类都有虚表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">CPerson</span>()&#123;</span><br><span class="line">            <span class="built_in">ShowSpeak</span>();	<span class="comment">//添加虚函数调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">CPerson</span>()&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowSpeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Speak No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况肯定是：子类构造函数-&gt;父类构造函数，但是在调用父类构造函数时，应该是Speak No，还是 Speak CountryWord 呢。一图解千愁：</p>
<p><img src="/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210831140327245.png" alt="image-20210831140327245"></p>
<p>析构函数同理，都会先设置虚表指针的。</p>
<hr>
<h3 id="定义其他对象-初始化列表"><a href="#定义其他对象-初始化列表" class="headerlink" title="定义其他对象+初始化列表"></a>定义其他对象+初始化列表</h3><p>初始化列表，见<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">附录</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerive</span> :</span> <span class="keyword">public</span> CBase&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">CDerive</span>():<span class="built_in">m_nDerive</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;使用初始化列表\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	CInit m_Init;		<span class="comment">//类中定义其他对象作为成员</span></span><br><span class="line">    	<span class="keyword">int</span> m_nDerive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    CDerive Derive 构造顺序如下：<br>​        构造父类-&gt;构造对象（按照声明顺序）-&gt;初始化列表-&gt;自身的构造函数代码。</p>
<h2 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h2><p>识别代码类与类之间的关系。只构造自己的类：基类。调用父类构造函数时，可以依靠虚表的交叉引用功能得到所有的虚构函数和构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span>&#123;</span>		<span class="comment">//基类-人类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPerson</span>()&#123;</span><br><span class="line">        <span class="built_in">ShowSpeak</span>();	<span class="comment">//注意，构造函数调用了虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CPerson</span>()&#123;</span><br><span class="line">        <span class="built_in">ShowSpeak</span>();	<span class="comment">//注意，析构函数调用了虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowSpeak</span><span class="params">()</span></span>&#123;		<span class="comment">//这个函数里调用了其他的虚函数GetClassName()</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s::ShowSpeak()\r\n&quot;</span>, <span class="built_in">GetClassName</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span>* <span class="title">GetClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CPerson&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CChinese</span> :</span> <span class="keyword">public</span> CPerson&#123;		<span class="comment">//中国人，继承自人类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">CChinese</span>()&#123;</span><br><span class="line">            <span class="built_in">ShowSpeak</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">CChinese</span>()&#123;</span><br><span class="line">            <span class="built_in">ShowSpeak</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span>* <span class="title">GetClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;CChinese&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    CPerson *pPerson = <span class="keyword">new</span> CChinese;</span><br><span class="line">    pPerson-&gt;<span class="built_in">ShowSpeak</span>();</span><br><span class="line">    <span class="keyword">delete</span> pPerson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">push FFFFFFFFh</span><br><span class="line">push offset unknown_libname_35; MicrosoftVisualC 2-9/net runtime</span><br><span class="line">mov eax, large fs:0</span><br><span class="line">push eax</span><br><span class="line">mov large fs:0, esp ; 注册c++异常处理</span><br><span class="line">push ecx</span><br><span class="line">push esi	;	保存寄存器环境</span><br><span class="line">push 4		; unsigned int</span><br><span class="line">call ??2@YAPAXI@Z ; operator new(uint) 申请4字节堆空间</span><br><span class="line">mov esi, eax; esi保存new调用的返回值</span><br><span class="line">add esp, 4	; 平衡new调用的参数</span><br><span class="line">mov [esp+14h+var_10], esi; new返回值保存到局部变量var_10中</span><br><span class="line">test esi, esi	;检查是否申请失败</span><br><span class="line">mov [esp+14h+var_4],0 ;计数标记</span><br><span class="line">jz short loc_4010F2		;申请失败的处理</span><br><span class="line">mov ecx, esi	;申请的空间给ecx</span><br><span class="line">mov dword ptr [esi], offset off_40C0DC	;这条指令在首地址处放置了函数指针数组地址  父类虚表</span><br><span class="line">;是虚表指针的初始化</span><br><span class="line">;没有调用构造函数，说明构造函数被编译器内联优化了</span><br><span class="line">call ds:off_40C0E4		;父类</span><br><span class="line">push eax</span><br><span class="line">push offset aSShowspeak; &quot;%s::ShowSpeak()\r\n&quot;</span><br><span class="line">call _printf</span><br><span class="line">add esp, 8</span><br><span class="line">mov ecx, esi</span><br><span class="line">mov byte ptr [esp+14h+var_4],1	;计数器+1</span><br><span class="line">mov dword ptr[esi], offset off_40C0D0	;写入子类虚表指针  子类</span><br><span class="line">call ds:off_40C0D8	;GetCChinese</span><br><span class="line">push eax</span><br><span class="line">push offset aSShowspeak ; &quot;%s::ShowSpeak()\r\n&quot;</span><br><span class="line">call _printf</span><br><span class="line">add esp,8	;平衡printf参数</span><br><span class="line">jmp short loc_4010F4</span><br><span class="line">xor esi, esi ; 0x4010F2 如果new调用的返回值为0，则esi为0</span><br><span class="line">===========================================说明1==========================================</span><br><span class="line">mov eax, [esi]	;取得虚表指针</span><br><span class="line">mov ecx, esi ; 传递this指针</span><br><span class="line">mov [esp+14h+var_4], FFFFFFFFh	;修改计数器</span><br><span class="line">call dword ptr [eax+4]	; 调用虚表第二项的函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">off_40C0D0:</span><br><span class="line">dd offset sub_4011C0	;虚表偏移0处，也就是虚表的的第一项</span><br><span class="line">dd offset sub_401140	;虚表偏移4处，也就是虚表的第二项</span><br><span class="line"></span><br><span class="line">off_40C0D8:		;暂时还不能确定这一项是否为虚表项，而sub_401140调用了第三个虚表项</span><br><span class="line">				;说明这也是虚表项之一</span><br><span class="line">dd offset sub_4011B0		;pfnGetCChinese</span><br><span class="line"></span><br><span class="line">++++++++++++++++++++++++++++++++++父子类虚表+++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">off_40C0DC:		;函数指针数组首地址	，分析有可能是虚表</span><br><span class="line">				;每个函数都有对ecx的引用，引用前未对ecx赋值</span><br><span class="line">dd offset sub_401170	;0x40C0DC</span><br><span class="line">dd offset sub_401140	;0x40C0E0</span><br><span class="line"></span><br><span class="line">off_40C0E4:		;函数指针</span><br><span class="line">dd offset sub_401160	;0x40C0E4		pfnGetCPerson</span><br><span class="line">;就在虚表附近，有可能是虚表的一部分</span><br><span class="line"></span><br><span class="line">----------------------------------------函数部分都在下面------------------------------------</span><br><span class="line"></span><br><span class="line">sub_401160:			;GetCPerson</span><br><span class="line">mov eax, offset aCperson	;返回名称的字符串</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">sub_4011B0:		;GetCChinese</span><br><span class="line">mov eax, offset aCchinese ; &quot;Chinese&quot;</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">sub_401140:		;未赋值就直接使用ecx，说明ecx在传递参数</span><br><span class="line">mov eax, [ecx] ; eax得到虚表</span><br><span class="line">call dword ptr [eax+8] ; 调用虚表第三项，形成了多态</span><br><span class="line">push eax	;向printf传入GetCChinese的返回值，是个字符串首地址</span><br><span class="line">push offset Format ; &quot;%s::ShowSpeak()\r\n&quot;</span><br><span class="line">call _printf</span><br><span class="line">add esp,8</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">sub_4011E0:	;析构</span><br><span class="line">push FFFFFFFF</span><br><span class="line">push offset unknown_libname_36; Microsoft VisualC 2-9/net runtime</span><br><span class="line">mov eax, large fs:0</span><br><span class="line">push eax</span><br><span class="line">mov large fs:0, esp</span><br><span class="line">push ecx	</span><br><span class="line">push esi	;从这往上注册异常，保留寄存器环境</span><br><span class="line">mov esi, ecx</span><br><span class="line">mov [esp+14h+var_10], esi</span><br><span class="line"></span><br><span class="line">;虚表指针处写入子类虚表地址</span><br><span class="line">mov dword ptr [esi], offset off_40C0D0</span><br><span class="line">mov [esp+14h+var_4], 0		;计数器置零</span><br><span class="line">call ds:pfnGetCChinese</span><br><span class="line">push eax		;获取字符串，并向printf传递参数</span><br><span class="line">push offset Format ; &quot;%s::ShowSpeak()\r\n&quot;</span><br><span class="line">call _printf</span><br><span class="line">add esp, 8			;执行printf，并平衡参数</span><br><span class="line">mov ecx, esi		;传递this指针</span><br><span class="line">mov [esp+14h+var_4], FFFFFFFFh		;将计数器置为-1</span><br><span class="line"></span><br><span class="line">;虚表指针写入父类虚表地址</span><br><span class="line">mov dword ptr [esi], offset off_40C0D0</span><br><span class="line">call ds:pfnGetCPerson</span><br><span class="line">push eax			;获取字符串，并向printf传递参数</span><br><span class="line">push offset Format	;&quot;%s::ShowSpeak()\r\n&quot;</span><br><span class="line">call _printf</span><br><span class="line"></span><br><span class="line">;流水线优化（这个没学过，需要补一补知识），因为mov large fs:0, ecx和当前指令依赖同一个寄存器ecx，会造成指令相关性</span><br><span class="line">;所以提前到add esp, 8之上，以提高流水线的并行能力</span><br><span class="line">mov ecx, [esp+1Ch+var_C]</span><br><span class="line">add esp, 8	;执行printf，并平衡参数</span><br><span class="line">mov large fs:0, ecx		;恢复环境并还原SEH</span><br><span class="line">pop esi</span><br><span class="line">add esp, 10h</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">;查看引用可知，这个函数是虚表off_40C0D0定义的第一个函数</span><br><span class="line">sub_4011C0:		;析构代理函数</span><br><span class="line">;arg0</span><br><span class="line">push esi</span><br><span class="line">mov esi, ecx ;esi保留了this指针</span><br><span class="line">call sub_4011E0	;调用析构函数</span><br><span class="line">test [esp+4+arg_0], 1	;test执行的是按位与操作</span><br><span class="line"></span><br><span class="line">jz short loc_4011D8</span><br><span class="line">push esi	;传入对象的首地址</span><br><span class="line">call ??3@YAXPAX@Z  ;operator delete(void *)</span><br><span class="line">add esp, 4	;调用delete，并平衡参数</span><br><span class="line"></span><br><span class="line">loc_4011D8</span><br><span class="line">mov eax, esi</span><br><span class="line">pop esi</span><br><span class="line">retn 4</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~析构代理外层函数~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">test esi, esi</span><br><span class="line">;当对象指针esi不为0时执行_Destructor_4011E0 析构函数</span><br><span class="line">jz short loc_40110F</span><br><span class="line">mov edx, [esi]	;edx获得虚表</span><br><span class="line">push 1	;传递参数值1</span><br><span class="line">mov ecx, esi ;传递this指针</span><br><span class="line">call dword ptr [edx] ;调用_Destructor_4011E0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明1：总体来说，构造函数先填父类虚表，再子类。以写入虚表指令为界限，可粗略划分出父子类构造函数的实现代码。</p>
<p>说明2：off_40C0D0这个虚表除了被main函数调用（构造函数内联进了main），另一个调用的地方就是析构函数了，所以寻找交叉引用。因为类有虚表，因此就算没有析构函数编译器也会自动添加析构函数。除此以外，查看父类有多少个派生类，也可以 使用交叉引用来查看。</p>
<p>由一个子类的构造函数交叉引用可以看到父类的地址，再由父类构造函数交叉引用可以看到其他子类的的地址（指没有被内联优化的情况下）</p>
<p>说明3：下面的这段代码就是显示调用析构函数，并且将pPerson指向的地址作为CChinese的新对象的首地址，并调用CChinese构造函数，这样可用重复使用一个堆内存，节约内存空间。由于显示调用析构函数时不能马上释放堆内存，因此析构函数的代理函数中通过一个参数控制是否释放内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">    CPerson *pPerson = <span class="keyword">new</span> CChinese;</span><br><span class="line">    pPerson-&gt;<span class="built_in">ShowSpeak</span>();</span><br><span class="line">    pPerson-&gt;~<span class="built_in">CPerson</span>();	<span class="comment">//显示调用析构函数，而非直接delete隐式调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解约内存空间</span></span><br><span class="line">	pPerson = <span class="built_in"><span class="keyword">new</span></span>(pPerson)<span class="built_in">CChinese</span>();<span class="comment">//这是什么语法</span></span><br><span class="line">    <span class="keyword">delete</span> pPerson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义沙发类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSofa</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">CSofa</span>()&#123;</span><br><span class="line">            m_nColor = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">CSofa</span>()&#123;					<span class="comment">//沙发类虚析构函数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;virtual ~CSofa()\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetColor</span><span class="params">()</span></span>&#123;				<span class="comment">//获取沙发颜色</span></span><br><span class="line">            <span class="keyword">return</span> m_nColor;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">SitDown</span><span class="params">()</span></span>&#123;				<span class="comment">//沙发可以坐下休息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Sit down and reset your legs\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="keyword">int</span> m_nColor;						<span class="comment">//沙发类成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义床类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBed</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">CBed</span>()&#123;</span><br><span class="line">            m_nLength = <span class="number">4</span>;</span><br><span class="line">            m_nWidth = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CBed</span>()&#123;						<span class="comment">//床类虚析构函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;virtual ~CBed()\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetArea</span><span class="params">()</span></span>&#123;					<span class="comment">//获取床面积</span></span><br><span class="line">        <span class="keyword">return</span> m_nLength * m_nWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Sleep</span><span class="params">()</span></span>&#123;					<span class="comment">//床可以用来睡觉</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;go to sleep\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span>:								<span class="comment">//床类成员变量</span></span><br><span class="line">    	<span class="keyword">int</span> m_nLength:</span><br><span class="line">    	<span class="keyword">int</span> m_nWidth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类沙发定义，派生自CSofa类和CBed类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSofaBed</span> :</span> <span class="keyword">public</span> CSofa, <span class="keyword">public</span> CBed&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">CSofaBed</span>()&#123;</span><br><span class="line">            m_nHeight = <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">CSofaBed</span>()&#123;				<span class="comment">//沙发类的虚析构函数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;virutal ~CSofaBed()\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">SitDown</span><span class="params">()</span></span>&#123;				<span class="comment">//沙发可以坐下休息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Sit down on the sofa bed\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Sleep</span><span class="params">()</span></span>&#123;				<span class="comment">//床可以用来睡觉</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;go to sleep on the sofa bed\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_nHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="keyword">int</span> m_nHeight;						<span class="comment">//沙发类的成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Sofa<ul>
<li>~CSofa</li>
<li>GetColor</li>
<li><strong><del>SitDown</del></strong></li>
</ul>
</li>
<li>CBed<ul>
<li> ~CBed</li>
<li> GetArea</li>
<li> <strong><del>Sleep</del></strong> </li>
</ul>
</li>
<li>CSofaBed<ul>
<li> ~CSofaBed</li>
<li> <strong>SitDown</strong></li>
<li> <strong>Sleep</strong></li>
<li> GetHeight</li>
</ul>
</li>
</ul>
<p>上面加粗的是父类部分与子类重合的虚函数，下图可以看到父类区域的虚表内，子类函数虚函数中没实现的，都由父类的虚函数填充了。</p>
<p><img src="/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210916155258109.png" alt="image-20210916155258109"></p>
<p>上面可以看到，编译器将子类的虚函数制作了两份，参考下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;CSofaBed SofaBed;</span><br><span class="line">lea ecx, [ebp-24h]	;传递this指针</span><br><span class="line">call (CSofaBed::CSofaBed)	;调用构造函数</span><br><span class="line">;分析构造函数 CSofaBed</span><br><span class="line">;CSofaBed()&#123;</span><br><span class="line">pop ecx		;还原this指针</span><br><span class="line">mov dowrd ptr [ebp-10h], ecx</span><br><span class="line">mov ecx, dword ptr [ebp-10h]	;以对象首地址作为this指针</span><br><span class="line">call CSofa::CSofa()		;调用沙发父类的构造函数 0x401073  ************************</span><br><span class="line">mov dword ptr [ebp-4], 0</span><br><span class="line">mov ecx, dword ptr [ebp-10h]</span><br><span class="line">add ecx, 8		;将this指针调整到第二个虚表指针地址处</span><br><span class="line">call CBed::CBed()	;0x401087  调用床父类的构造函数		************************</span><br><span class="line">mov eax, dword ptr [ebp-10h]	;获取第二个虚表指针地址</span><br><span class="line">;设置虚表指针</span><br><span class="line">mov dword ptr [eax], offset CSofaBed::&#x27;vftable&#x27;	;0x426198		*************************</span><br><span class="line">mov ecx, dword ptr [ebp-10h]	;获取对象首地址</span><br><span class="line">;设置虚表指针</span><br><span class="line">mov dword ptr [ecx+8], offset CSofaBed::&#x27;vftable&#x27;	;0x42501c	*************************</span><br><span class="line">;部分略</span><br><span class="line">ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从左到右调用构造函数，先是<strong>CSofa</strong>再是<strong>CBed</strong>。这里因为有两个父类，因此子类继承的时候将他们的虚表指针一起继承了过来，因此有了两个虚表指针。<strong>多重继承中，子类虚表指针的个数取决于所继承的父类的个数</strong>，虚基类除外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;CSofaBed SofaBed;</span><br><span class="line">;CSofa *pSofa = &amp;SofaBed;</span><br><span class="line">lea eax, [ebp-24h]		;直接将首地址转换为父类指针（见上面代码片段）</span><br><span class="line">mov dowrd ptr [ebp-28h],eax</span><br><span class="line">;CBed * pBed = &amp;SofaBed;</span><br><span class="line">lea ecx,[ebp-24h]</span><br><span class="line">test ecx,ecx	;检查对象首地址</span><br><span class="line">je	0x40f751	;错误处理</span><br><span class="line">lea edx,[ebp-1Ch]	;即lea edx, [ebp-24h+8h]调整为CBed指针</span><br><span class="line">mov dword ptr [ebp-30h],edx</span><br><span class="line">jmp 0x40f758</span><br><span class="line">mov dword ptr [ebp-30h],0	;0x40F751</span><br><span class="line">mov eax, dword ptr [ebp-30h]	;0x40f758</span><br><span class="line">mov dword ptr [ebp-2Ch],eax		;保存调整后的this指针</span><br></pre></td></tr></table></figure>

<p>​    转换为Bed指针的时候，调整首地址并<strong>跳过</strong>了第一个父类所占用的空间，这样使用CBed指针访问CBed中的成员和虚函数时，就不会错误地寻址到继承自CSofa类的成员变量。</p>
<p><strong>多继承类析构函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">;子类析构函数</span><br><span class="line">;virtual ~CSofaBed()&#123;</span><br><span class="line">;部分代码略</span><br><span class="line">pop ecx</span><br><span class="line">mov dword ptr [ebp-10h], ecx</span><br><span class="line">mov eax, dword ptr [ebp-10h]</span><br><span class="line">;两个虚表指针设置为各个父类虚表首地址</span><br><span class="line">mov dword ptr [eax], offset CSofaBed::&#x27;vftable&#x27; ;0x012FF5C CSofa——第一个父类的虚表</span><br><span class="line">mov ecx, dword ptr [ebp-10h]</span><br><span class="line">mov dword ptr [ecx+8], offset CSofaBed::&#x27;vftable&#x27; ;0x12FF64	CBed——第二个父类的虚表</span><br><span class="line">mov dword ptr [ebp-4],0</span><br><span class="line">;执行子类虚函数内代码</span><br><span class="line">;printf(&quot;virtual ~CSofaBed()\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">;比较对象地址，与子类对象转化为父类指针相似</span><br><span class="line">cmp dword ptr [ebp-10h],0	;当this==NULL时不需调整</span><br><span class="line">je CSofaBed::~CSofaBed+6Ah	;0x40174a</span><br><span class="line">mov edx, dword ptr [ebp-10h]</span><br><span class="line">add edx, 8</span><br><span class="line">mov dword ptr [ebp-14h], edx	;将调整后的this指针保存到[ebp-14h]</span><br><span class="line">jmp CSofaBed::~CSofaBed+71h.0x401751</span><br><span class="line">mov dword ptr [ebp-14h], 0</span><br><span class="line">mov ecx, dword ptr [ebp-14h]	;0x401751</span><br><span class="line">;调用父类CBed的析构函数</span><br><span class="line">call CBed::~CBed.0x401050		;**************************************</span><br><span class="line">mov dword ptr [ebp-4], FFFFFFFFh</span><br><span class="line">mov ecx, dword ptr [ebp-10h]</span><br><span class="line">;无需转换this指针，直接调用CSofa的析构函数</span><br><span class="line">cal CSofa::~CSofa.0x401082		;**************************************</span><br><span class="line">mov ecx, dword ptr [ebp-0Ch]</span><br><span class="line">mov dword ptr fs:[0], ecx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>​    因为有多个父类，所以编译器根据每个父类在对象中占用的<strong>空间位置</strong>，<strong>对应传入</strong>各个父类部分首地址作为this指针。</p>
<h3 id="特征总结"><a href="#特征总结" class="headerlink" title="特征总结"></a>特征总结</h3><ul>
<li>单继承类<ul>
<li>在类对象占用的内存空间中，只保存一份虚表指针（<strong>注意更换父子类虚表的时机</strong>）</li>
<li>只有一个虚表指针，只有一个虚表</li>
<li>虚表中保存类虚函数首地址</li>
<li>构造时先父后子</li>
<li>析构时先子后父</li>
</ul>
</li>
<li>多重继承类<ul>
<li>根据继承<strong>父类个数</strong>保存虚表指针</li>
<li>转换父类指针需要<strong>跳转到对象首地址</strong></li>
<li>构造时用到<strong>多个父类构造函数</strong></li>
<li>继承的父类<strong>从左到右</strong>依次构造</li>
<li>析构相反顺序</li>
</ul>
</li>
</ul>
<p>对象作为成员时，类对象内存结构和多重继承相似。成员有虚函数的时候，可以看虚函数属于哪个类来区分。但成员没有虚函数的时候， 整个类对象的内存结构和多重继承完全一样，酌情还原。</p>
<h1 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h1><p>虚基类需要和虚函数配合使用，编程的时候在虚函数声明结尾处添加”=0”。这个被称为纯虚函数，纯虚函数没有实现、只有声明。虚基类的存在时为了让继承的子类<strong>都有虚表以及虚表指针</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirutalBase</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtualChild</span> ;</span> <span class="keyword">public</span> CVirtualBase&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;虚基类分析\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    CVirutalChild VirutalChild;</span><br><span class="line">    VirutalChild.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">;CVirutalBase::CVirtualBse;</span><br><span class="line">pop ecx</span><br><span class="line">mov dword ptr [ebp-4], ecx</span><br><span class="line">mov eax,dword ptr [ebp-4]</span><br><span class="line">;设置虚基类虚表指针，虚表地址在0x425068处</span><br><span class="line">mov dword ptr [eax], offset CVirtualBase::&#x27;vftable&#x27;.0x425068</span><br><span class="line">mov eax,dword ptr [ebp-4]</span><br><span class="line">ret</span><br><span class="line">;虚基类CVirutalBase中虚表信息的第一项所指向的函数首地址</span><br><span class="line">;void __cdecl _purecall(void)&#123;</span><br><span class="line">push ebp		;0x401E90</span><br><span class="line">mov ebp,esp</span><br><span class="line">;_amsg_exit(_RT_PUREVIRT);</span><br><span class="line">push 19h					;压入错误编码</span><br><span class="line">call _amsg_exit.0x401fd0	;结束程序</span><br><span class="line">add esp,4</span><br><span class="line">&#125;</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<blockquote>
<p>address: 0x425068            value: 90 1E 40 00</p>
</blockquote>
<p>​    为了防止错误调用纯虚函数，将虚表中保存的纯虚函数的首地址项替换成了函数_purecall<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.cnblogs.com/yilang/p/11824849.html">[4]</span></a></sup>，用于结束程序，并发出错误编码信息0x19。因此根据这一特性，分析中<strong>虚表中一旦发现函数地址为_purecall的地址</strong>，我们就可以高度怀疑虚表对应的是一个<strong>虚基类</strong>。<br>​    当虚基类中定义了<strong>多个</strong>纯虚函数时，虚表中将保存<strong>相同的函数指针</strong>。</p>
<h1 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h1><p>​    这么一个继承关系D::(B,C)::A，这种继承关系呈菱形，故称菱形继承。</p>
<p><img src="/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210918114232827.png" alt="image-20210918114232827"></p>
<p>这里面会多这么两个字段。表示祖先类在整个结构中的偏移。</p>
<p><img src="/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210918114328733.png" alt="image-20210918114328733"></p>
<p>上图对应的内存结构：</p>
<p><img src="/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210918114718569.png" alt="image-20210918114718569"></p>
<blockquote>
<p>addr:0x425050        value: FC FF FF FF (-4)        对应于所属类的偏移                    vt_offset<br>addr:0x425054        value: 1C 00 00 00             对应于父类的偏移</p>
</blockquote>
<blockquote>
<p>addr:0x425044        value:FC FF FF FF (-4)        对应于所属类的偏移                    vt_offset<br>addr:0x425048        value: 10 00 00 00            对应于父类的偏移</p>
</blockquote>
<p>上面记录的偏移会在【<strong>指针转换</strong>】的时候使用。</p>
<p>再根据上面两个图看看虚表指针。分别是0x425034**(CSofa)<strong>, 0x425028</strong>(CBed),** 0x42501C**(CFurniture)**</p>
<p>父类中的虚函数都是子类中没实现的。</p>
<p><img src="/images/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/image-20210918115710515.png" alt="image-20210918115710515"></p>
<p>补充下父子类的虚函数</p>
<ul>
<li>CFurniture<ul>
<li>~CFurniture</li>
<li>GetPrice</li>
</ul>
</li>
<li>CSofa<ul>
<li>~CSofa</li>
<li>GetColor</li>
<li><strong><del>SitDown</del></strong></li>
</ul>
</li>
<li>CBed<ul>
<li>~CBed</li>
<li>GetArea</li>
<li><strong><del>Sleep</del></strong></li>
</ul>
</li>
<li>CSofaBed<ul>
<li>~CSofaBed</li>
<li><strong>SitDown</strong></li>
<li><strong>Sleep</strong></li>
<li>GetHeight</li>
</ul>
</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">;CSofaBed SofaBed;</span><br><span class="line">push 1				;压入参数1</span><br><span class="line">lea ecx, [ebp-34h]</span><br><span class="line">call CSofaBed::CSofaBed.0x40100f</span><br><span class="line">;CSofaBed()&#123;</span><br><span class="line">pop ecx</span><br><span class="line">mov dword ptr [ebp-10h],ecx		;this指针</span><br><span class="line">mov dword ptr [ebp-14h],0		;传入构造标记</span><br><span class="line">;比较参数是否为0，0则跳转，防止重复构造</span><br><span class="line">cmp dword ptr [ebp+8], 0</span><br><span class="line">je CSofaBed::CSofaBed+6Eh.0x40123e</span><br><span class="line">mov eax, dword ptr [ebp-10h]</span><br><span class="line">;设置父类CSofa中的vt_offset域</span><br><span class="line">mov dword ptr [eax+4], offset CSofaBed::&#x27;vbtable&#x27;.0x425050</span><br><span class="line">mov ecx, dword ptr [ebp-10h]</span><br><span class="line">;设置父类CBed中的vt_offset域</span><br><span class="line">mov dword ptr [eax+4], offset CSofaBed::&#x27;vbtable&#x27;.0x425044</span><br><span class="line">mov ecx,dowrd ptr [ebp-10h]</span><br><span class="line">add ecx,20h			;调整this指针</span><br><span class="line"></span><br><span class="line">*********************上面写好了几个偏移表*********************</span><br><span class="line"></span><br><span class="line">;调用祖父类构造函数，祖父类为最上级，它的构造函数和无继承关系的构造函数相同</span><br><span class="line">call CFurniture::CFurniture.0x401032</span><br><span class="line">mov edx, dword ptr [ebp-14h]	;获取构造标记</span><br><span class="line">or edx, 1						;将构造标记置1</span><br><span class="line">mov dowrd ptr [ebp-14h],edx		;修改构造标记</span><br><span class="line">mov dword ptr [ebp-4],0</span><br><span class="line">push 0							;压入0作为构造标记</span><br><span class="line">mov ecx, dword ptr [ebp-10h]	;获取对象首地址作为this指针</span><br><span class="line">call CSofa::CSofa.0x401073		;调用父类构造函数</span><br><span class="line">mov dword ptr [ebp-4],1</span><br><span class="line">push 0							;压入0作为构造标记</span><br><span class="line">mov ecx,dword ptr [ebp-10h]</span><br><span class="line">add ecx, 0Ch					;调整this指针</span><br><span class="line">call CBed::CBed.0x401087		;调用父类构造函数</span><br><span class="line">mov eax, dword ptr [ebp-10h]</span><br><span class="line">;CSofaBed对应CSofa的虚表指针</span><br><span class="line">mov dword ptr [eax], offset CSofaBed::&#x27;vftable&#x27;.0x425034</span><br><span class="line">mov ecx,dword ptr [ebp-10h]</span><br><span class="line">;CSofaBed对应CBed的虚表指针</span><br><span class="line">mov dword ptr [ecx+0Ch],offset CSofaBed::&#x27;vftable&#x27;.0x425028</span><br><span class="line">mov edx,dword ptr [ebp-10h]		;通过this指针和vt_offset定位到祖父类的虚表指针</span><br><span class="line">mov eax,dword ptr [edx+4]		;vt_offset存入eax中</span><br><span class="line">mov ecx,dword ptr [eax+4]		;父类虚表指针相对vt_offset的偏移存入eax中</span><br><span class="line">mov edx,dword ptr [ebp-10h]</span><br><span class="line">;CSofaBed对应CFurniture的虚表指针</span><br><span class="line">mov dword ptr [edx+ecx+4],offset CSofaBed::&#x27;vftable&#x27;.0x42501C</span><br><span class="line">;m_nHeight = 6</span><br><span class="line">mov eax, dword ptr [ebp-10h]</span><br><span class="line">mov dword ptr [eax+1Ch],6</span><br><span class="line">&#125;</span><br><span class="line">ret 4</span><br></pre></td></tr></table></figure>



<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="c-三种继承方式"><a href="#c-三种继承方式" class="headerlink" title="c++三种继承方式"></a>c++三种继承方式</h3><table>
<thead>
<tr>
<th></th>
<th><strong>public成员</strong></th>
<th><strong>protected成员</strong></th>
<th><strong>private成员</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>public继承</strong></td>
<td>public</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr>
<td><strong>protected继承</strong></td>
<td>protected</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr>
<td><strong>private继承</strong></td>
<td>private</td>
<td>private</td>
<td>不可见</td>
</tr>
</tbody></table>
<p>另外，使用【using】关键字可以改变基类成员在派生类中的访问权限。当然只能改变基类中的public和protected成员访问权限，因为private在派生类中本来就不可见。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> People&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">using</span> People::m_name;	<span class="comment">//将protected改为public</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">using</span> People::show;		<span class="comment">//将public改为private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考自“C语言中文网“</p>
<hr>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="comment">//构造函数初始化列表</span></span><br><span class="line">    <span class="built_in">CExample</span>(): <span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="number">8.8</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//构造函数内部赋值</span></span><br><span class="line">    <span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">        b=<span class="number">8.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考自<a href="#https://www.runoob.com/w3cnote/cpp-construct-function-initial-list.html">菜鸟教程</a></p>
<h2 id="关于虚函数和纯虚函数"><a href="#关于虚函数和纯虚函数" class="headerlink" title="关于虚函数和纯虚函数"></a>关于虚函数和纯虚函数</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hackbuteer1/article/details/7558868">https://blog.csdn.net/hackbuteer1/article/details/7558868</a></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">加密与解密中经常看到代码中有【m_】开头的变量，在<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/2217.html">这里</a>可以看到解释：“成员变量大都以m_开头，这是约定俗称的写法”，这样可以一眼就看出是成员变量，而且还可以和形参进行区别。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">这个时候父类有构造函数。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">编译器会提供构造函数帮助父类初始化虚表。<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://www.cnblogs.com/yilang/p/11824849.html<a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/04/%E9%9D%92%E6%98%A5%E4%B9%8B%E6%AD%8C%E8%AF%BB%E5%90%8E%E6%84%9F/" rel="prev" title="青春之歌——用信仰奏响">
                  <i class="fa fa-chevron-left"></i> 青春之歌——用信仰奏响
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NewbieReer</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  




  





</body>
</html>
